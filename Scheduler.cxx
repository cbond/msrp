#include <algorithm>
#include <cassert>

#include "msrp/System.hxx"
#include "msrp/OutgoingMessage.hxx"
#include "msrp/Scheduler.hxx"
#include "msrp/Session.hxx"

using namespace msrp;
using namespace std;
using namespace boost;

Scheduler::Scheduler()
{}

shared_ptr<Session>
Scheduler::process()
{
   shared_ptr<OutgoingMessage> msg = thread();
   if (msg)
   {
      return msg->session();
   }

   return shared_ptr<Session>();
}

shared_ptr<OutgoingMessage>
Scheduler::thread()
{
   sort(mQueue.begin(), mQueue.end());

   while (!mQueue.empty())
   {
      try
      {
         return mQueue.begin()->get();
      }
      catch (const bad_weak_ptr&)
      {
         mQueue.erase(mQueue.begin());
      }
   }

   return shared_ptr<OutgoingMessage>();
}

void
Scheduler::queue(shared_ptr<OutgoingMessage> m)
{
   mQueue.push_back(Thread(m));
}

void
Scheduler::erase(shared_ptr<OutgoingMessage> m)
{
   vector<Thread>::iterator i = find(mQueue.begin(), mQueue.end(), Thread(m));

   if (i != mQueue.end())
   {
      mQueue.erase(i);
   }
}

// Scheduler::Thread

Scheduler::Thread::Thread(shared_ptr<OutgoingMessage> m) :
   mMsg(m)
{}

shared_ptr<OutgoingMessage>
Scheduler::Thread::get() const
{
   return shared_ptr<OutgoingMessage>(mMsg);
}

bool
Scheduler::Thread::operator<(const Thread& r) const
{
   try
   {
      shared_ptr<OutgoingMessage> lhs(get());
      assert(lhs);

      shared_ptr<OutgoingMessage> rhs(r.get());
      assert(rhs);

      // !cb! If the message has been interrupted, move it to the front of the
      // run queue so that this can be indicated to the remote party without
      // waiting for a large block of data to be sent.
      if (lhs->interrupted() != rhs->interrupted())
      {
         return lhs->interrupted();
      }

      // Move non-runnable messages to the back of the queue.
      if (lhs->runnable() != rhs->runnable())
      {
         return lhs->runnable();
      }

      // Sort based on amount of data queued.
      if (lhs->queued() > rhs->queued())
      {
         return true;
      }
      else if (lhs->queued() < rhs->queued())
      {
         return false;
      }

      // Sort based on time of last transfer.
      return lhs->lastTransfer() < rhs->lastTransfer();
   }
   catch (const bad_weak_ptr&)
   {}

   return false;
}

bool
Scheduler::Thread::operator==(const Thread& rhs) const
{
   try
   {
      return get() == rhs.get();
   }
   catch (const bad_weak_ptr&)
   {}

   return false;
}

// Copyright 2007 Chris Bond
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
