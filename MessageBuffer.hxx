#ifndef MSRP_MESSAGECONTENTS_HXX
#define MSRP_MESSAGECONTENTS_HXX

#include <cassert>
#include <cstddef>
#include <memory>
#include <stdexcept>
#include <string>

#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/spirit.hpp>
#include <boost/range.hpp>

#include <asio/buffer.hpp>

#include "msrp/Exception.hxx"
#include "msrp/Message.hxx"

namespace msrp
{

class MessageBuffer
{
   public:
      struct Exception : public msrp::Exception
      {
         Exception(const std::string& s, const ExceptionContext& context) :
            msrp::Exception(s, context)
         {}
      };

      MessageBuffer(std::size_t size = 65536);

      asio::mutable_buffer mutableBuffer()
      {
         return asio::mutable_buffer(&mBuffer.get()[mStored], mBufferSize - mStored);
      }

      asio::const_buffer buffer() const
      {
         return asio::const_buffer(mBuffer.get(), mStored);
      }

      // contents in context of the message
      asio::const_buffer contents() const;

      // free buffer space for incoming data
      void erase();

      // reset parse state and buffer
      void reset();

      // indicate that data has been read into mutableBuffer()
      void read(std::size_t);

      enum State
      {
         Status,   // wait for status line
         Headers,  // wait for header block
         Content,  // wait for contents
         Complete  // full message received
      };

      State state() const
      {
         return mState;
      }

      Message::MsgStatus status() const
      {
         return mStatus;
      }

      Message::Method method() const
      {
         return mMethod;
      }

      // If the buffer goes from State::Status to Complete in one read, you may
      // wish to parse the message including contents.  If you know the message
      // will be disposed of before you call erase or reset on MessageBuffer,
      // you may create a Data overlay for the contents to avoid a copy.  If
      // the entire message has not received, you will generally want to preparse
      // to figure out where to route the message and then read the contents with
      // MessageBuffer::contents() afterward.
      enum ParseMode
      {
         CopyContents,
         OverlayContents,
         NoContents
      };
      boost::shared_ptr<Message> parse(const ParseMode) const;

   private:
      typedef const char* const_iterator;

      boost::scoped_ptr<char> mBuffer;

      std::size_t mBufferSize;
      std::size_t mStored;

      State mState;

      Message::Method mMethod;

      Message::MsgStatus mStatus;

      // transaction ID
      std::string mTid;

      boost::spirit::rule<> mParser;

      boost::iterator_range<const_iterator> mStatusRange;
      boost::iterator_range<const_iterator> mHeaderRange;
      boost::iterator_range<const_iterator> mContentRange;
      boost::iterator_range<const_iterator> mTokenRange;

      bool getTransaction(boost::iterator_range<const_iterator>&);
      bool getHeader(boost::iterator_range<const_iterator>&);
      bool getEndToken(boost::iterator_range<const_iterator>&);

      void setContentRange();

      std::size_t offset(const_iterator i) const;

      // erase pointers into the buffer without erasing the buffer
      void resetRanges();

      // search in reverse for the end token
      const_iterator reverseKey(const_iterator, std::size_t) const;

      // based on mTransactionId
      const std::string endToken() const;

      static const std::size_t Safety;
};

}

#endif

// Copyright 2007 Chris Bond
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
