#include <cctype>
#include <memory>
#include <sstream>
#include <iostream>

#include <boost/algorithm/string.hpp>

#include "msrp/System.hxx"
#include "msrp/Parse.hxx"
#include "msrp/ParseException.hxx"
#include "msrp/ParseUri.hxx"
#include "msrp/ParserFactory.hxx"
#include "msrp/Uri.hxx"

using namespace msrp;
using namespace std;

Uri::Uri() :
   mPort(0), mDelimiter(false)
{}

Uri::Uri(const string& str) :
   mPort(0), mDelimiter(false)
{
   parse(str);
}

Uri::Uri(const asio::ip::tcp::endpoint& endpoint, bool tls) :
   mHost(endpoint.address().to_string()),
   mPort(endpoint.port()),
   mDelimiter(false)
{
   if (tls)
   {
      mScheme = "msrps";
   }
   else
   {
      mScheme = "msrp";
   }
}

void
Uri::parse(const string& s)
{
   Parse(*this, asio::const_buffer(s.c_str(), s.size()), ParserFactory<parser::Uri>::get());
}

bool
Uri::operator<(const Uri& rhs) const
{
   stringstream ls;
   stringstream rs;

   ls << this[0];
   rs << rhs;

   return ls.str() < rs.str();
}

bool
Uri::operator==(const Uri& rhs) const
{
   return mUser == rhs.mUser
      && mSessionId == rhs.mSessionId
      && mPort == rhs.mPort
      && boost::algorithm::iequals(mScheme, rhs.mScheme)
      && boost::algorithm::iequals(mHost, rhs.mHost)
      && boost::algorithm::iequals(mTransport, rhs.mTransport);
}

bool
Uri::operator!=(const Uri& rhs) const
{
   return !(*this == rhs);
}

bool
Uri::tls() const
{
   return boost::algorithm::iequals(scheme(), "msrps");
}

bool
Uri::empty() const
{
   return mScheme.empty()
      && mUser.empty()
      && mHost.empty()
      && mSessionId.empty()
      && mTransport.empty()
      && mPort == 0;
}

const asio::ip::tcp::endpoint
Uri::endpoint() const
{
   asio::ip::tcp::endpoint endpoint;
   
   endpoint.address(asio::ip::address::from_string(host()));
   endpoint.port(port());

   return endpoint;
}

const Path
Uri::path() const
{
   Path p;
   p.push_back(*this);

   return p;
}

ostream&
msrp::operator<<(ostream& os, const Uri& uri)
{
   if (uri.empty())
   {
      return os;
   }

   if (uri.scheme().empty())
   {
      os << "msrp";
   }
   else
   {
      os << uri.scheme();
   }

   os << ':';

   if (uri.mDelimiter)
   {
      os << "//";
   }

   if (!uri.user().empty())
   {
      os << uri.user();
      os << '@';
   }

   os << uri.host();

   if (uri.port())
   {
      os << ':';
      os << uri.port();
   }

   if (!uri.session().empty())
   {
      os << '/';
      os << uri.session();
   }

   if (!uri.transport().empty())
   {
      os << ';';
      os << uri.transport();
   }

   return os;
}

ostream&
msrp::operator<<(ostream& os, const Path& path)
{
   Path::const_iterator i = path.begin();
   while (i != path.end())
   {
      os << *i;

      if (++i != path.end())
      {
         os << ' ';
      }
   }

   return os;
}

// Copyright 2007 Chris Bond
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
