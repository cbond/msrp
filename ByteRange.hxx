#ifndef MSRP_BYTERANGE_HXX
#define MSRP_BYTERANGE_HXX

#include <limits>
#include <ostream>

#include <boost/spirit.hpp>
#include <boost/spirit/actor.hpp>
#include <boost/spirit/attribute/closure.hpp>
#include <boost/spirit/phoenix/binders.hpp>

namespace msrp
{

#undef min
#undef max

struct ByteRangeTuple
{
   typedef unsigned int size_type;

   ByteRangeTuple(size_type s = 0,
         size_type e = std::numeric_limits<size_type>::max(),
         size_type t = std::numeric_limits<size_type>::max()) :
      start(s), end(e), total(t)
   {}

   size_type start;
   size_type end;
   size_type total;
};

std::ostream&
operator<<(std::ostream&, const ByteRangeTuple&);

namespace parser
{

struct ByteRangeClosure :
   boost::spirit::closure<ByteRangeClosure, ByteRangeTuple>
{
   member1 range;
};

struct ByteRange :
   boost::spirit::grammar<ByteRange, ByteRangeClosure::context_t>
{
   template<typename ScannerT>
   struct definition
   {
      definition(const ByteRange& self)
      {
         using phoenix::bind;
         using phoenix::val;

         static const ByteRangeTuple::size_type unknown =
            std::numeric_limits<ByteRangeTuple::size_type>::max();

         root = segment[bind(&ByteRangeTuple::start)(self.range) = phoenix::arg1]
            >> '-'
            >> (segment
                    [bind(&ByteRangeTuple::end)(self.range) = phoenix::arg1]
               | boost::spirit::ch_p('*')
                    [bind(&ByteRangeTuple::end)(self.range) = val(unknown)]
               )
            >> boost::spirit::ch_p('/')
            >> (segment
                    [bind(&ByteRangeTuple::total)(self.range) = phoenix::arg1]
               | boost::spirit::ch_p('*')
                    [bind(&ByteRangeTuple::total)(self.range) = val(unknown)]
               )
            ;
      }

      boost::spirit::rule<ScannerT> root;
      boost::spirit::uint_parser<unsigned, 10> segment;

      boost::spirit::rule<ScannerT> const& start() const
      {
         return root;
      }
   };
};

} // namespace parser

}

#endif

// Copyright 2007 Chris Bond
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
