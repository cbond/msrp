#ifndef MSRP_OUTGOINGMESSAGE_HXX
#define MSRP_OUTGOINGMESSAGE_HXX

#include <cassert>

#include <boost/enable_shared_from_this.hpp>
#include <boost/function.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

#include <rutil/Data.hxx>

#include "msrp/Connection.hxx"
#include "msrp/MessageSessionBase.hxx"
#include "msrp/Scheduler.hxx"

namespace msrp
{

class Message;
class Session;

class OutgoingMessage :
   public boost::noncopyable,
   public boost::enable_shared_from_this<OutgoingMessage>,
   public MessageSessionBase
{
   public:
      class StreamFunctor
      {
         public:
            StreamFunctor(OutgoingMessage&, boost::shared_ptr<Connection>);

            void operator()(const resip::Data& data);
            void operator()(const asio::const_buffer& buffer);

         private:
            OutgoingMessage& mOutgoing;

            boost::shared_ptr<Connection> mConnection;
      };

      OutgoingMessage(boost::shared_ptr<Session>, const Message&);

      virtual ~OutgoingMessage();

      // !cb! Interrupt the outgoing data stream, cancelling the message.
      virtual void cancel();

      boost::signal1<void, const Message&>& onReport();

      boost::signal1<void, Message&>& onContextRequired();

      // !cb! Size of zero indicates that the application can choose any amount
      // of data to queue through the StreamFunctor.  If size is nonzero, and
      // you choose to write more data than `size,' then the remaining data
      // will be queued and sent as part of the next message.
      boost::signal2<void, std::size_t, StreamFunctor&>& onDataRequired();

      // alternative to automatic management using signals above
      void send(const asio::const_buffer&);

   private:
      friend class Demultiplex;
      friend class Session;
      friend class Scheduler;
      friend class Scheduler::Thread;
      friend class StreamContext;

      // process an incoming report
      bool process(boost::shared_ptr<const Message>);

      void start();
      void end();
      void end(boost::shared_ptr<Connection>);
      void run();

      bool runnable() const;

      std::size_t queued() const;

      resip::Data mQueued;

      std::size_t mFragment;

      boost::shared_ptr<Session> session() const;

      boost::weak_ptr<Session> mSession;

      boost::signal1<void, Message&> mContext;
      boost::signal1<void, const Message&> mReport;
      boost::signal2<void, std::size_t, StreamFunctor&> mData;
};

}

#endif

// Copyright 2007 Chris Bond
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
